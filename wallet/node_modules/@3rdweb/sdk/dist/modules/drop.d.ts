import { LazyMintERC721 as DropV2 } from "@3rdweb/contracts";
import { TransactionReceipt } from "@ethersproject/providers";
import { BigNumber, BigNumberish, BytesLike } from "ethers";
import { ModuleType, Role } from "../common";
import { NFTMetadata, NFTMetadataOwner } from "../common/nft";
import { ThirdwebSDK } from "../core";
import { ModuleWithRoles } from "../core/module";
import { MetadataURIOrObject, ProviderOrSigner } from "../core/types";
import { ClaimEligibility } from "../enums";
import ClaimConditionFactory from "../factories/ClaimConditionFactory";
import { ITransferable } from "../interfaces/contracts/ITransferable";
import { ISDKOptions } from "../interfaces/ISdkOptions";
import { ClaimCondition, PublicMintCondition } from "../types/claim-conditions/PublicMintCondition";
import { QueryAllParams } from "../types/QueryParams";
/**
 * @beta
 */
export interface CreatePublicMintCondition {
    startTimestampInSeconds?: BigNumberish;
    maxMintSupply: BigNumberish;
    quantityLimitPerTransaction?: BigNumberish;
    waitTimeSecondsLimitPerTransaction?: BigNumberish;
    pricePerToken?: BigNumberish;
    currency?: string;
    merkleRoot?: BytesLike;
}
export interface BatchToReveal {
    batchId: BigNumber;
    batchUri: string;
    placeholderMetadata: NFTMetadata;
}
/**
 * Setup a collection of one-of-one NFTs that are minted as users claim them.
 *
 * @example
 *
 * ```javascript
 * import { ThirdwebSDK } from "@3rdweb/sdk";
 *
 * // You can switch out this provider with any wallet or provider setup you like.
 * const provider = ethers.Wallet.createRandom();
 * const sdk = new ThirdwebSDK(provider);
 * const module = sdk.getDropModule("{{module_address}}");
 * ```
 *
 * @public
 */
export declare class DropModule extends ModuleWithRoles<DropV2> implements ITransferable {
    private _shouldCheckVersion;
    private _isV0;
    private _version;
    private v1Module;
    static moduleType: ModuleType;
    static roles: readonly ["admin", "minter", "transfer"];
    /**
     * @internal
     */
    constructor(providerOrSigner: ProviderOrSigner, address: string, options: ISDKOptions, sdk: ThirdwebSDK);
    /**
     * @internal
     */
    setProviderOrSigner(providerOrSigner: ProviderOrSigner): void;
    /**
     * @override
     * @internal
     */
    protected getModuleRoles(): readonly Role[];
    /**
     * @internal
     */
    protected connectContract(): DropV2;
    /**
     * @internal
     */
    protected getModuleType(): ModuleType;
    private getTokenMetadata;
    get(tokenId: string): Promise<NFTMetadataOwner>;
    /**
     * Get All NFTs
     *
     * @remarks Get all the data associated with every NFT in this module.
     *
     * @example
     * ```javascript
     * const nfts = await module.getAll();
     * console.log(nfts);
     * ```
     *
     * @returns The NFT metadata for all NFTs in the module.
     */
    getAll(queryParams?: QueryAllParams): Promise<NFTMetadataOwner[]>;
    getAllUnclaimed(queryParams?: QueryAllParams): Promise<NFTMetadataOwner[]>;
    getAllClaimed(queryParams?: QueryAllParams): Promise<NFTMetadataOwner[]>;
    ownerOf(tokenId: string): Promise<string>;
    getDefaultSaleRecipient(): Promise<string>;
    setDefaultSaleRecipient(recipient: string): Promise<TransactionReceipt>;
    /**
     * Get Owned NFTs
     *
     * @remarks Get all the data associated with the NFTs owned by a specific wallet.
     *
     * @example
     * ```javascript
     * // Address of the wallet to get the NFTs of
     * const address = "{{wallet_address}}";
     * const nfts = await module.getOwned(address);
     * console.log(nfts);
     * ```
     *
     * @returns The NFT metadata for all NFTs in the module.
     */
    getOwned(_address?: string): Promise<NFTMetadataOwner[]>;
    /**
     * @deprecated - For backward compatibility reason
     */
    private transformResultToMintCondition;
    private transformResultToClaimCondition;
    /**
     * @deprecated - Use {@link DropModule.getActiveClaimCondition} instead
     */
    getActiveMintCondition(): Promise<PublicMintCondition>;
    getActiveClaimCondition(): Promise<ClaimCondition>;
    /**
     * @deprecated - Use {@link DropModule.getAllClaimConditions} instead
     */
    getAllMintConditions(): Promise<PublicMintCondition[]>;
    getAllClaimConditions(): Promise<ClaimCondition[]>;
    totalSupply(): Promise<BigNumber>;
    /**
     * @internal
     */
    maxTotalSupply(): Promise<BigNumber>;
    totalUnclaimedSupply(): Promise<BigNumber>;
    totalClaimedSupply(): Promise<BigNumber>;
    /**
     * Get NFT Balance
     *
     * @remarks Get a wallets NFT balance (number of NFTs in this module owned by the wallet).
     *
     * @example
     * ```javascript
     * // Address of the wallet to check NFT balance
     * const address = "{{wallet_address}}";
     *
     * const balance = await module.balanceOf(address);
     * console.log(balance);
     * ```
     */
    balanceOf(address: string): Promise<BigNumber>;
    balance(): Promise<BigNumber>;
    isApproved(address: string, operator: string): Promise<boolean>;
    setApproval(operator: string, approved?: boolean): Promise<TransactionReceipt>;
    /**
     * Transfer NFT
     *
     * @remarks Transfer an NFT from the connected wallet to another wallet.
     *
     * @example
     * ```javascript
     * // Address of the wallet you want to send the NFT to
     * const toAddress = "{{wallet_address}}";
     *
     * // The token ID of the NFT you want to send
     * const tokenId = "0";
     *
     * await module.transfer(toAddress, tokenId);
     * ```
     */
    transfer(to: string, tokenId: string): Promise<TransactionReceipt>;
    /**
     * @deprecated - The function has been deprecated. Use `createBatch` instead.
     */
    lazyMint(metadata: MetadataURIOrObject): Promise<void>;
    /**
     * @deprecated - The function has been deprecated. Use `createBatch` instead.
     */
    lazyMintBatch(metadatas: MetadataURIOrObject[]): Promise<void>;
    /**
     * @deprecated - Use {@link DropModule.setClaimCondition} instead
     */
    setMintConditions(factory: ClaimConditionFactory): Promise<TransactionReceipt>;
    /**
     * @deprecated - Use {@link DropModule.setClaimCondition} instead
     */
    setClaimConditions(factory: ClaimConditionFactory): Promise<TransactionReceipt>;
    /**
     * Sets public mint conditions for the next minting using the
     * claim condition factory.
     *
     * @param factory - The claim condition factory.
     */
    setClaimCondition(factory: ClaimConditionFactory): Promise<TransactionReceipt>;
    updateClaimConditions(factory: ClaimConditionFactory): Promise<TransactionReceipt>;
    /**
     * Creates a claim condition factory
     *
     * @returns - A new claim condition factory
     */
    getClaimConditionsFactory(): ClaimConditionFactory;
    /**
     * @deprecated - Use the {@link DropModule.getClaimConditionsFactory} instead.
     */
    getMintConditionsFactory(): ClaimConditionFactory;
    /**
     * @deprecated - Use the {@link DropModule.setClaimConditions} instead.
     */
    setPublicMintConditions(conditions: CreatePublicMintCondition[]): Promise<void>;
    /**
     * For any claim conditions that a particular wallet is violating,
     * this function returns human readable information about the
     * breaks in the condition that can be used to inform the user.
     *
     * @param quantity - The desired quantity that would be claimed.
     *
     */
    getClaimIneligibilityReasons(quantity: BigNumberish, addressToCheck?: string): Promise<ClaimEligibility[]>;
    /**
     * Can Claim
     *
     * @remarks Check if the drop can currently be claimed.
     *
     * @example
     * ```javascript
     * // Quantity of tokens to check if they are claimable
     * const quantity = 1;
     *
     * await module.canClaim(quantity);
     * ```
     */
    canClaim(quantity: BigNumberish, addressToCheck?: string): Promise<boolean>;
    /**
     * Returns proofs and the overrides required for the transaction.
     *
     * @returns - `overrides` and `proofs` as an object.
     */
    private prepareClaim;
    /**
     * Claim NFTs to Wallet
     *
     * @remarks Let the a specified wallet claim NFTs.
     *
     * @example
     * ```javascript
     * // Address of the wallet you want to claim the NFTs
     * const address = "{{wallet_address}}";
     *
     * // The number of NFTs to claim
     * const quantity = 1;
     *
     * await module.claimTo(quantity, address);
     * ```
     *
     * @param quantity - Quantity of the tokens you want to claim
     * @param addressToClaim - Address you want to send the token to
     * @param proofs - Array of proofs
     *
     * @returns - Receipt for the transaction
     */
    claimTo(quantity: BigNumberish, addressToClaim: string, proofs?: BytesLike[]): Promise<TransactionReceipt>;
    /** Claim NFTs
     *
     * @param quantity - Quantity of the tokens you want to claim
     * @param proofs - Array of proofs
     *
     * @returns - Receipt for the transaction
     */
    claim(quantity: BigNumberish, proofs?: BytesLike[]): Promise<NFTMetadataOwner[]>;
    burn(tokenId: BigNumberish): Promise<TransactionReceipt>;
    transferFrom(from: string, to: string, tokenId: BigNumberish): Promise<TransactionReceipt>;
    setModuleMetadata(metadata: MetadataURIOrObject): Promise<TransactionReceipt>;
    setRoyaltyBps(amount: number): Promise<TransactionReceipt>;
    /**
     * Gets the royalty BPS (basis points) of the contract
     *
     * @returns - The royalty BPS
     */
    getRoyaltyBps(): Promise<BigNumberish>;
    /**
     * Gets the address of the royalty recipient
     *
     * @returns - The royalty BPS
     */
    getRoyaltyRecipientAddress(): Promise<string>;
    /**
     * Create batch allows you to create a batch of tokens
     * in one transaction. This function can only be called
     * once per module at the moment.
     *
     * @beta
     *
     * @param metadatas - The metadata to include in the batch.
     */
    createBatch(metadatas: MetadataURIOrObject[]): Promise<string[]>;
    /**
     * Algorithm to hash delay reveal password, so we don't broadcast the input password on-chain.
     *
     * @internal
     */
    private hashDelayRevealPassword;
    /**
     * Create batch allows you to create a batch of tokens
     * in one transaction. This function can only be called
     * once per module at the moment.
     *
     * @param metadatas - The metadata to include in the batch.
     */
    createDelayedRevealBatch(placeholder: MetadataURIOrObject, metadatas: MetadataURIOrObject[], password: string): Promise<string[]>;
    reveal(batchId: BigNumberish, password: string): Promise<void>;
    /**
     * Gets a list of token uris that needs to be revealed.
     */
    getBatchesToReveal(): Promise<BatchToReveal[]>;
    /**
     * @internal
     *
     * @returns - True if the batch has been created, false otherwise.
     */
    canCreateBatch(): Promise<boolean>;
    /**
     * Check if contract is v0 or not. If the contract doesn't have nextTokenIdToMint = v0 contract.
     * @internal
     */
    private isV0;
    /**
     * @internal
     */
    private isNewClaim;
    /**
     * @internal
     */
    hasDelayedReveal(): Promise<boolean>;
    /**
     * @internal
     */
    private checkVersion;
    /**
     * Fetches the proof for the current signer for a particular wallet.
     *
     * @param merkleRoot - The merkle root of the condition to check.
     * @returns - The proof for the current signer for the specified condition.
     */
    private getClaimerProofs;
    isTransferRestricted(): Promise<boolean>;
    setRestrictedTransfer(restricted?: boolean): Promise<TransactionReceipt>;
}
