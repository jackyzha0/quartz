import { SignatureMint721 } from "@3rdweb/contracts";
import { TransactionReceipt } from "@ethersproject/providers";
import { BigNumber, BigNumberish } from "ethers";
import { ModuleType, Role } from "../common";
import { NFTMetadata, NFTMetadataOwner } from "../common/nft";
import { ModuleWithRoles } from "../core/module";
import { MetadataURIOrObject } from "../core/types";
import { ITransferable } from "../interfaces/contracts/ITransferable";
import { ISignatureMinter } from "../interfaces/modules/ISignatureMinter";
import { NewSignaturePayload } from "../types/signature-minting/NewSignaturePayload";
import { SignaturePayload } from "../types/signature-minting/SignaturePayload";
/**
 * Create a collection of one-of-one NFTs.
 *
 * @example
 *
 * ```javascript
 * import { ThirdwebSDK } from "@3rdweb/sdk";
 *
 * // You can switch out this provider with any wallet or provider setup you like.
 * const provider = ethers.Wallet.createRandom();
 * const sdk = new ThirdwebSDK(provider);
 * const module = sdk.getNFTModule("{{module_address}}");
 * ```
 *
 * @public
 */
export declare class NFTModule extends ModuleWithRoles<SignatureMint721> implements ITransferable, ISignatureMinter {
    static moduleType: ModuleType;
    static roles: readonly ["admin", "minter", "transfer"];
    protected getModuleRoles(): readonly Role[];
    /**
     * @internal
     */
    protected connectContract(): SignatureMint721;
    /**
     * @internal
     */
    protected getModuleType(): ModuleType;
    private _shouldCheckVersion;
    private _isV1;
    private v1Contract?;
    /**
     * Check if contract is v1 or v2. If the contract doesn't have nextTokenIdToMint = v1 contract.
     */
    isV1(): Promise<boolean>;
    /**
     * Fetches an NFT from storage with the resolved metadata.
     *
     * @param tokenId - The id of the token to fetch.
     * @returns - The NFT metadata.
     */
    get(tokenId: string): Promise<NFTMetadata>;
    /**
     * Get All NFTs
     *
     * @remarks Get all the data associated with every NFT in this module.
     *
     * @example
     * ```javascript
     * const nfts = await module.getAll();
     * console.log(nfts);
     * ```
     *
     * @returns The NFT metadata for all NFTs in the module.
     */
    getAll(): Promise<NFTMetadata[]>;
    getWithOwner(tokenId: string): Promise<NFTMetadataOwner>;
    getAllWithOwner(): Promise<NFTMetadataOwner[]>;
    /**
     * Checks the owner of a particular NFT
     *
     * @param tokenId - ID of the NFT to get the owner of
     * @returns the owner of the token, or a zero address if the
     * token has been burned
     */
    ownerOf(tokenId: string): Promise<string>;
    /**
     * Get Owned NFTs
     *
     * @remarks Get all the data associated with the NFTs owned by a specific wallet.
     *
     * @example
     * ```javascript
     * // Address of the wallet to get the NFTs of
     * const address = "{{wallet_address}}";
     * const nfts = await module.getOwned(address);
     * console.log(nfts);
     * ```
     */
    getOwned(_address?: string): Promise<NFTMetadata[]>;
    totalSupply(): Promise<BigNumber>;
    /**
     * Get NFT Balance
     *
     * @remarks Get a wallets NFT balance (number of NFTs in this module owned by the wallet).
     *
     * @example
     * ```javascript
     * // Address of the wallet to check NFT balance
     * const address = "{{wallet_address}}";
     *
     * const balance = await module.balanceOf(address);
     * console.log(balance);
     * ```
     *
     * @returns The balance of the NFTs in the wallet
     */
    balanceOf(address: string): Promise<BigNumber>;
    balance(): Promise<BigNumber>;
    isApproved(address: string, operator: string): Promise<boolean>;
    setApproval(operator: string, approved?: boolean): Promise<TransactionReceipt>;
    /**
     * Transfer NFT
     *
     * @remarks Transfer an NFT from the connected wallet to another wallet.
     *
     * @example
     * ```javascript
     * // Address of the wallet you want to send the NFT to
     * const toAddress = "{{wallet_address}}";
     *
     * // The token ID of the NFT you want to send
     * const tokenId = "0";
     *
     * await module.transfer(toAddress, tokenId);
     * ```
     */
    transfer(to: string, tokenId: string): Promise<TransactionReceipt>;
    mint(metadata: MetadataURIOrObject): Promise<NFTMetadata>;
    private _v1MintTo;
    /**
     * Mint NFT
     *
     * @remarks Mint an NFT to a specified wallet.
     *
     * @example
     * ```javascript
     * // Address of the wallet you want to mint the NFT to
     * const toAddress = "{{wallet_address}}"
     *
     * // Custom metadata of the NFT, note that you can fully customize this metadata with other properties.
     * const metadata = {
     *   name: "Cool NFT",
     *   description: "This is a cool NFT",
     *   image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
     * }
     *
     * await module.mintTo(toAddress, metadata);
     * ```
     */
    mintTo(to: string, metadata: MetadataURIOrObject): Promise<NFTMetadata>;
    mintBatch(metadatas: MetadataURIOrObject[]): Promise<NFTMetadata[]>;
    private _v1MintBatchTo;
    /**
     * Mint Many NFTs
     *
     * @remarks Mint many NFTs at once to a specified wallet.
     *
     * @example
     * ```javascript
     * // Address of the wallet you want to mint the NFT to
     * const toAddress = "{{wallet_address}}"
     *
     * // Custom metadata of the NFTs you want to mint.
     * const metadatas = [{
     *   name: "Cool NFT #1",
     *   description: "This is a cool NFT",
     *   image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
     * }, {
     *   name: "Cool NFT #2",
     *   description: "This is a cool NFT",
     *   image: fs.readFileSync("path/to/other/image.png"),
     * }];
     *
     * await module.mintBatchTo(toAddress, metadatas);
     * ```
     */
    mintBatchTo(to: string, metadatas: MetadataURIOrObject[]): Promise<NFTMetadata[]>;
    /**
     * Burn NFT
     *
     * @remarks Burn an NFT, permanently taking it out of circulation and reducing the supply.
     *
     * @example
     * ```javascript
     * // The token ID of the NFT you want to burn
     * const tokenId = 0;
     *
     * await module.burn(tokenId);
     * ```
     */
    burn(tokenId: BigNumberish): Promise<TransactionReceipt>;
    transferFrom(from: string, to: string, tokenId: BigNumberish): Promise<TransactionReceipt>;
    setRoyaltyBps(amount: number): Promise<TransactionReceipt>;
    setModuleMetadata(metadata: MetadataURIOrObject): Promise<TransactionReceipt>;
    /**
     * Gets the royalty BPS (basis points) of the contract
     *
     * @returns - The royalty BPS
     */
    getRoyaltyBps(): Promise<BigNumberish>;
    /**
     * Gets the address of the royalty recipient
     *
     * @returns - The royalty BPS
     */
    getRoyaltyRecipientAddress(): Promise<string>;
    /**
     * Set the default primary sales recipient for this contract
     * @param address - the wallet that should receive the proceeds from primary sales
     */
    setPrimarySaleRecipient(address: string): Promise<TransactionReceipt>;
    getPrimarySaleRecipient(): Promise<string>;
    getDefaultSaleRecipient(): Promise<string>;
    /**
     * Set the default primary sales recipient for this contract
     * @param recipient - the wallet that should receive the proceeds from primary sales
     */
    setDefaultSaleRecipient(recipient: string): Promise<TransactionReceipt>;
    isTransferRestricted(): Promise<boolean>;
    setRestrictedTransfer(restricted?: boolean): Promise<TransactionReceipt>;
    mintWithSignature(req: SignaturePayload, signature: string): Promise<BigNumber>;
    verify(mintRequest: SignaturePayload, signature: string): Promise<boolean>;
    generateSignatureBatch(payloads: NewSignaturePayload[]): Promise<{
        payload: SignaturePayload;
        signature: string;
    }[]>;
    generateSignature(mintRequest: NewSignaturePayload): Promise<{
        payload: SignaturePayload;
        signature: string;
    }>;
    /**
     * Maps a payload to the format expected by the contract
     *
     * @internal
     *
     * @param mintRequest - The payload to map.
     * @returns - The mapped payload.
     */
    private mapPayload;
    private setAllowance;
}
